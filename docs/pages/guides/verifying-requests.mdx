# Verifying Requests

Learn how to verify ERC-8128 signed requests on your server.

## Overview

Verification confirms that a request was signed by the claimed Ethereum address and hasn't been tampered with. The process checks:

- Signature validity (cryptographic verification)
- Timing (created/expires window)
- Replay protection (nonce consumption)
- Request binding (signed components match)

## Basic Verification

The simplest way to verify a request using [verifyRequest](/api/verifyRequest):

```typescript
import { verifyRequest } from '@slicekit/erc8128'

const result = await verifyRequest(request, verifyMessage, nonceStore)

if (result.ok) {
  console.log(`Authenticated: ${result.address}`)
  console.log(`Chain: ${result.chainId}`)
} else {
  console.log(`Failed: ${result.reason}`)
}
```

## Using createVerifierClient

For repeated verification with the same dependencies, use [createVerifierClient](/api/createVerifierClient) to bind `verifyMessage` and `nonceStore`:

```typescript
import { createVerifierClient } from '@slicekit/erc8128'

const verifier = createVerifierClient(verifyMessage, nonceStore, {
  maxValiditySec: 120,
})

const result = await verifier.verifyRequest(request, { strictLabel: true })
```

## Required Setup

### Nonce Store

For replay protection, you need a store that tracks consumed nonces.

:::code-group

```typescript [Redis (Production)]
import type { NonceStore } from '@slicekit/erc8128'
import { Redis } from 'ioredis'

const redis = new Redis()

export const nonceStore: NonceStore = {
  async consume(key: string, ttlSeconds: number) {
    const result = await redis.set(`nonce:${key}`, '1', 'EX', ttlSeconds, 'NX')
    return result === 'OK'
  },
}
```

```typescript [In-Memory (Development)]
import type { NonceStore } from '@slicekit/erc8128'

const seen = new Set<string>()

export const nonceStore: NonceStore = {
  consume: async (key: string) => {
    if (seen.has(key)) return false
    seen.add(key)
    return true
  },
}
```

:::

## Policy Configuration

Choose the appropriate policy based on your endpoint's security requirements:

:::code-group

```typescript [Strict (Mutations)]
// For high-security endpoints that modify state
const result = await verifyRequest(request, verifyMessageFn, nonceStore, {
  replayable: false,
  maxValiditySec: 60,       // Short window
  maxNonceWindowSec: 60,
  clockSkewSec: 5,          // Small tolerance
})
```

```typescript [Relaxed (Reads)]
// For idempotent read operations
const result = await verifyRequest(request, verifyMessageFn, nonceStore, {
  replayable: true,         // Allow replayable signatures
  maxValiditySec: 300,      // Longer window
  clockSkewSec: 30,         // More tolerance
})
```

:::

### Label Selection

When multiple signatures exist on a request:

:::code-group

```typescript [Default (Prefer Label)]
// Prefer "eth" label, fall back to first valid
const result = await verifyRequest(request, verifyMessageFn, nonceStore, {
  label: 'eth',
})
```

```typescript [Strict (Require Label)]
// Require exact label match
const result = await verifyRequest(request, verifyMessageFn, nonceStore, {
  label: 'user',
  strictLabel: true,  // Fail if "user" label not found
})
```

:::

### Component Policies

By default, the verifier enforces that signatures are **request-bound** — covering `@authority`, `@method`, `@path`, plus `@query` and `content-digest` when the request has a query string or body. This rejects all class-bound signatures. Non-replayable request-bound signatures always pass when their components match the required policy. Other cases depend on the configured policies and signature params (e.g. `replayable`, class-bound policy, timing, nonce window).

Use `additionalRequestBoundComponents` to require additional components alongside the default request-bound set. Use `classBoundPolicies` to opt into class-bound signatures by listing acceptable component sets (order does not matter):

```typescript
// Default: rejects class-bound signatures (full request-bound check)
const result = await verifyRequest(request, verifyMessageFn, nonceStore)

// Require custom headers in request-bound signatures
const result = await verifyRequest(request, verifyMessageFn, nonceStore, {
  additionalRequestBoundComponents: ['x-idempotency-key'],
})

// Accept class-bound signatures that cover a minimal policy
const result = await verifyRequest(request, verifyMessageFn, nonceStore, {
  classBoundPolicies: ['@authority', '@method'],
})
```

See [Server Enforcement](/concepts/request-binding#server-enforcement-with-requestboundcomponents-and-classboundpolicies) for details on default behavior, custom components, and the difference between request-bound and class-bound verification.

## Framework Integration

Drop `verifyRequest` into middleware or route handlers. These examples show integration patterns for Hono, Next.js, and Express.

:::code-group

```typescript [Hono]
import { verifyRequest } from '@slicekit/erc8128'
import { createMiddleware } from 'hono/factory'

const erc8128Auth = createMiddleware(async (c, next) => {
  const result = await verifyRequest(c.req.raw, verifyMessageFn, nonceStore, {
    maxValiditySec: 300,
  })

  if (!result.ok) {
    return c.json({ error: 'Unauthorized', reason: result.reason }, 401)
  }

  c.set('auth', {
    address: result.address,
    chainId: result.chainId,
  })

  await next()
})
```

```typescript [Next.js]
import { verifyRequest } from '@slicekit/erc8128'
import type { NextRequest } from 'next/server'

export async function POST(req: NextRequest) {
  const result = await verifyRequest(req, verifyMessageFn, nonceStore)

  if (!result.ok) {
    return Response.json({ error: result.reason }, { status: 401 })
  }

  // Authenticated! Use result.address
  return Response.json({ address: result.address })
}
```

```typescript [Express]
import { verifyRequest } from '@slicekit/erc8128'
import type { Request, Response, NextFunction } from 'express'

const erc8128Auth = async (req: Request, res: Response, next: NextFunction) => {
  // Convert Express request to Fetch Request
  const url = `${req.protocol}://${req.get('host')}${req.originalUrl}`
  const fetchRequest = new Request(url, {
    method: req.method,
    headers: req.headers as HeadersInit,
    body: req.method !== 'GET' ? JSON.stringify(req.body) : undefined,
  })

  const result = await verifyRequest(fetchRequest, verifyMessageFn, nonceStore, {
    maxValiditySec: 300,
  })

  if (!result.ok) {
    return res.status(401).json({
      error: 'Unauthorized',
      reason: result.reason,
    })
  }

  // Attach identity to request
  req.auth = {
    address: result.address,
    chainId: result.chainId,
  }

  next()
}
```

:::

## Handling Failures

When verification fails, inspect `result.reason` to return appropriate HTTP status codes and error messages.

```typescript
const result = await verifyRequest(request, verifyMessageFn, nonceStore, policy)

if (!result.ok) {
  switch (result.reason) {
    case 'missing_headers':
      // No signature present
      return { status: 401, error: 'Authentication required' }
      
    case 'expired':
    case 'not_yet_valid':
      // Time-based rejection
      return { status: 401, error: 'Signature expired or not yet valid' }
      
    case 'replay':
      // Nonce reuse detected
      return { status: 401, error: 'Request replay detected' }
      
    case 'bad_signature':
      // Cryptographic verification failed
      return { status: 401, error: 'Invalid signature' }
      
    case 'digest_mismatch':
      // Body was tampered
      return { status: 400, error: 'Body integrity check failed' }
      
    default:
      return { status: 401, error: `Authentication failed: ${result.reason}` }
  }
}
```

## Multi-Chain Support

The `chainId` in the verification result tells you which chain the signer claims to be on:

```typescript
if (result.ok) {
  const { address, chainId } = result

  // Verify the signer has permissions on this chain
  const hasAccess = await checkPermissions(address, chainId)

  if (!hasAccess) {
    // Return 403 Forbidden
  }
}
```

## Best Practices

1. **Always use nonce stores in production** — In-memory stores don't work across server restarts or multiple instances.

2. **Keep validity windows short** — 60-300 seconds is reasonable. Longer windows increase replay risk.

3. **Use strict label matching** when you expect a specific signature source.

4. **Log verification failures** — They can indicate attacks or client bugs.

5. **Consider clock skew** — Allow 5-30 seconds for network latency and clock drift.

6. **Use Redis or a distributed store** — Essential for multi-instance deployments.
