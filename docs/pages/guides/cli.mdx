# eth-fetch CLI

Command-line tool for signing HTTP requests with ERC-8128. Think of it as curl with built-in Ethereum authentication.

## Overview

`eth-fetch` lets you make HTTP requests signed with your Ethereum account directly from the command line. Useful for:

- Testing ERC-8128-enabled APIs
- Quick authenticated requests without writing code
- Debugging and inspecting signed request headers
- Scripting authenticated API calls

## Installation

Install globally via npm:

```bash
npm install -g @slicekit/erc8128-cli
```

Or use directly with npx:

```bash
npx @slicekit/erc8128-cli <url>
```

## Basic Usage

```bash
eth-fetch [options] <url>
```

The simplest request:

```bash
eth-fetch --private-key 0x... https://api.example.com/data
```

## Examples

### Simple GET Request

```bash
eth-fetch --private-key 0x... https://api.example.com/data
```

### POST with JSON Data

```bash
eth-fetch -X POST \
  -H "Content-Type: application/json" \
  -d '{"foo":"bar"}' \
  --private-key 0x... \
  https://api.example.com/submit
```

### Using Keystore File

More secure than raw private keys:

```bash
eth-fetch --keystore ./keyfile.json https://api.example.com/data
```

You'll be prompted for the password interactively. Or provide it explicitly:

```bash
eth-fetch --keystore ./keyfile.json --password mypass https://api.example.com/data
```

### Using Environment Variable

```bash
export ETH_PRIVATE_KEY=0x...
eth-fetch https://api.example.com/data
```

### Verbose Output

See the full request details including headers:

```bash
eth-fetch -v --private-key 0x... https://api.example.com/data
```

### Save Response to File

```bash
eth-fetch -o response.json --private-key 0x... https://api.example.com/data
```

### Include Response Headers

```bash
eth-fetch -i --private-key 0x... https://api.example.com/data
```

### Custom Signature Options

Configure chain ID, binding mode, replay protection, and TTL:

```bash
eth-fetch \
  --chain-id 137 \
  --binding class-bound \
  --replay replayable \
  --ttl 300 \
  --private-key 0x... \
  https://api.example.com/data
```

## Options Reference

### HTTP Options

| Option | Description |
|--------|-------------|
| `-X, --request <method>` | HTTP method (GET, POST, etc.) [default: GET] |
| `-H, --header <header>` | Add header (repeatable) |
| `-d, --data <data>` | Request body |
| `-o, --output <file>` | Write response to file |
| `-i, --include` | Include response headers in output |
| `-v, --verbose` | Show request details |

### Wallet Options

| Option | Description |
|--------|-------------|
| `--private-key <key>` | Raw private key (⚠️ insecure) |
| `--keystore <path>` | Path to encrypted keystore file |
| `--password <pass>` | Keystore password (or prompts interactively) |

**Environment Variable:** Set `ETH_PRIVATE_KEY` to provide a private key.

### ERC-8128 Options

| Option | Default | Description |
|--------|---------|-------------|
| `--chain-id <id>` | `1` | Ethereum chain ID |
| `--binding <mode>` | `request-bound` | `request-bound` or `class-bound` |
| `--replay <mode>` | `non-replayable` | `non-replayable` or `replayable` |
| `--ttl <seconds>` | `60` | Signature validity in seconds |

## Security Considerations

:::warning
Using `--private-key` or the `ETH_PRIVATE_KEY` environment variable is **insecure** as the key may be visible in shell history or process listings.

For better security:
- Use `--keystore` with an encrypted keystore file
:::

### Best Practices

1. **Use keystore files** — Encrypted at rest, only decrypted in memory
2. **Clear shell history** — If you used `--private-key`, clear it from history
3. **Avoid scripts with raw keys** — Use environment variables injected at runtime from a secrets manager
4. **Use short TTLs** — Default 60 seconds is good; shorter is better for sensitive operations

## How It Works

`eth-fetch` uses the [ERC-8128](https://eips.ethereum.org/EIPS/eip-8128) standard to sign HTTP requests:

1. Creates an Ethereum signer from your wallet
2. Builds the HTTP request with your specified options
3. Signs the request according to ERC-8128 (adds `Signature-Input`, `Signature`, and `Content-Digest` headers)
4. Sends the signed request and displays the response

## Next Steps

- [Signing Requests](/guides/signing-requests) — Programmatic signing with the library
- [Verifying Requests](/guides/verifying-requests) — Server-side verification
- [Request Binding](/concepts/request-binding) — Understanding binding modes
