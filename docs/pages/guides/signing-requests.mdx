# Signing Requests

Learn how to sign HTTP requests with ERC-8128.

## Overview

ERC-8128 signing creates cryptographic proof that an HTTP request was authorized by a specific Ethereum address. The signature covers the request components (method, URL, headers, body) and includes timing/replay protection.

With a signed request, servers can:
- Authenticate users by their Ethereum address (no passwords or API keys)
- Verify request integrity (tampering detection)
- Prevent replay attacks (via nonces)

## Basic Signing

The simplest way to sign a request using [signRequest](/api/signRequest):

```typescript
import { signRequest } from '@slicekit/erc8128'

const signedRequest = await signRequest(
  'https://api.example.com/resource',
  signer
)
```

This uses all defaults:
- **Request-bound** — signs authority, method, path, query, body digest
- **Non-replayable** — auto-generated nonce
- **60-second TTL**
- **Label: "eth"**

## Creating a Signer

Implement the `EthHttpSigner` interface by providing a chain ID, address, and `signMessage` function. This example uses viem's `privateKeyToAccount`:

```typescript
import type { EthHttpSigner } from '@slicekit/erc8128'
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0x...')

const signer: EthHttpSigner = {
  chainId: 1,
  address: account.address,
  signMessage: async (message) => {
    return account.signMessage({ message: { raw: message } })
  },
}
```

## Using createClient

For repeated requests, use [createClient](/api/createClient) to bind the signer:

```typescript
import { createClient } from '@slicekit/erc8128'

const client = createClient(signer, {
  ttlSeconds: 120,
})

// Use client.fetch
const response = await client.fetch('https://api.example.com/orders', {
  method: 'POST',
  body: JSON.stringify({ amount: '100' }),
})

// Override options per-call
const response = await client.fetch(
  'https://api.example.com/status',
  { method: 'GET' },
  { replay: 'replayable' }
)
```

## Signing Options

Customize TTL, timestamps, nonce generation, and other signature parameters via `SignOptions`.

:::code-group

```typescript [Custom TTL]
const signedRequest = await signRequest(
  'https://api.example.com/resource',
  signer,
  { ttlSeconds: 300 } // Valid for 5 minutes
)
```

```typescript [Explicit Timestamps]
const now = Math.floor(Date.now() / 1000)

const signedRequest = await signRequest(
  'https://api.example.com/resource',
  signer,
  {
    created: now,
    expires: now + 120, // 2 minutes
  }
)
```

```typescript [Custom Nonce]
const signedRequest = await signRequest(
  'https://api.example.com/resource',
  signer,
  { nonce: `request-${crypto.randomUUID()}` }
)
```

```typescript [Async Nonce Generator]
const signedRequest = await signRequest(
  'https://api.example.com/resource',
  signer,
  {
    nonce: async () => {
      const res = await fetch('https://nonce.example.com/generate')
      return res.text()
    },
  }
)
```

:::

## Binding Modes

Request-bound (default) signs all applicable components for maximum security. Class-bound signs only the components you explicitly specify.

:::code-group

```typescript [Request-Bound (Default)]
// Signs all applicable components for maximum security
const signedRequest = await signRequest(
  'https://api.example.com/search?q=test',
  { method: 'POST', body: '{"data": true}' },
  signer,
  { binding: 'request-bound' }
)

// Signature covers: @authority, @method, @path, @query, content-digest
```

```typescript [Class-Bound]
// Signs only specified components — authorizes a class of requests
const signedRequest = await signRequest(
  'https://api.example.com/any-endpoint',
  signer,
  {
    binding: 'class-bound',
    components: ['@authority'],  // Only sign the domain
    replay: 'replayable',        // Often combined for performance
  }
)
```

:::

### Class-Bound

Class-bound signatures authorize a *class of requests* rather than a single concrete request. By signing only specific components, a single signature can apply to multiple requests that match the signed components.

This is useful when:
- You want a single signature to work across multiple endpoints on the same domain
- You're optimizing for performance in high-frequency scenarios
- You're building delegation or session-like patterns

When using `binding: 'class-bound'`, you must provide the `components` array explicitly. The library always includes `@authority` (required by the spec).

:::warning
Class-bound signatures weaken request integrity — the verifier must explicitly opt in to accepting them. A server that only accepts request-bound signatures (the default) will reject class-bound signatures. See [Server Enforcement](/concepts/request-binding#server-enforcement-with-requiredcomponents) for how verifiers control this.
:::

### Additional Components

Sign extra headers alongside the default request-bound set:

```typescript
const signedRequest = await signRequest(
  request,
  signer,
  { components: ['x-idempotency-key', 'x-request-id'] }
)

// Signature covers: @authority, @method, @path, content-digest, 
//                   x-idempotency-key, x-request-id
```

## Replay Modes

Non-replayable (default) includes a unique nonce per request. Replayable omits the nonce — use only for safe, idempotent operations.

:::code-group

```typescript [Non-Replayable (Default)]
// Every request gets a unique nonce
const signedRequest = await signRequest(
  'https://api.example.com/resource',
  signer,
  { replay: 'non-replayable' }
)
```

```typescript [Replayable]
// No nonce — use only for safe, idempotent operations
const signedRequest = await signRequest(
  'https://api.example.com/status',
  { method: 'GET' },
  signer,
  { replay: 'replayable' }
)
```

:::

:::warning
Replayable signatures can be replayed by anyone who intercepts them. Only use for safe, idempotent operations.
:::

## Content-Digest

### Automatic (Default)

Content-Digest is computed automatically for request-bound requests with a body:

```typescript
const signedRequest = await signRequest(
  'https://api.example.com/data',
  {
    method: 'POST',
    body: JSON.stringify({ data: 'value' }),
  },
  signer
)

// Content-Digest header added automatically
```

### Manual Control

Disable automatic Content-Digest computation when you want to handle it yourself or skip it entirely.

```typescript
const signedRequest = await signRequest(
  request,
  signer,
  { contentDigest: 'off' } // Don't add Content-Digest
)
```

## Error Handling

Catch `Eip8128Error` to handle signing failures with structured error codes.

```typescript
import { signRequest, Eip8128Error } from '@slicekit/erc8128'

try {
  const signedRequest = await signRequest(input, signer)
} catch (error) {
  if (error instanceof Eip8128Error) {
    console.error(`Signing failed: ${error.code} - ${error.message}`)
  }
  throw error
}
```

Common errors:
- `CRYPTO_UNAVAILABLE` — No WebCrypto (older Node.js or restricted environment)
- `UNSUPPORTED_REQUEST` — Can't sign this request (e.g., invalid URL)
- `BODY_READ_FAILED` — Couldn't read request body for Content-Digest
