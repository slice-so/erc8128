---
const steps = [
  {
    id: "sign",
    title: "Sign",
    description:
      "The client signs the request — URL, body, expiry, nonce — choosing the security posture."
  },
  {
    id: "send",
    title: "Send",
    description:
      "The signed request is sent with the client's Ethereum address and signature."
  },
  {
    id: "verify",
    title: "Verify",
    description:
      "The server verifies the signature binds to the request, and authenticates the client."
  }
]
---

<section class="relative overflow-hidden border-b border-border px-4 py-24 md:px-12 md:py-32">
  <!-- Grid background -->
  <div class="absolute inset-0 opacity-10 pointer-events-none bg-grid"></div>

  <div class="max-w-7xl mx-auto relative z-10">
    <div class="mb-16 md:mb-20">
      <div class="text-xl font-bold uppercase tracking-[0.15em] flex items-center gap-4">
        <span class="block w-4 h-4 bg-white"></span>
        Request Lifecycle
      </div>
    </div>

    <div class="relative grid grid-cols-1 md:grid-cols-3 gap-16 md:gap-0" id="hiw-grid">
      <!-- Connection line fill (desktop only) -->
      <svg
        class="connection-flow hidden md:block absolute top-[84px] left-[17%] w-[66.67%] h-8 z-0"
        viewBox="0 0 800 32"
        preserveAspectRatio="none"
        aria-hidden="true"
      >
        <line x1="0" y1="16" x2="800" y2="16" stroke="rgba(255,255,255,0.06)" stroke-width="1" />
        <line
          id="hiw-line-fill"
          x1="0"
          y1="16"
          x2="800"
          y2="16"
          stroke="rgba(167, 139, 250, 0.9)"
          stroke-width="1.2"
          stroke-linecap="round"
          pathLength="1"
        />
        <line
          id="hiw-line-return"
          x1="0"
          y1="16"
          x2="800"
          y2="16"
          stroke="var(--hiw-green)"
          stroke-width="1.2"
          stroke-linecap="round"
          pathLength="1"
          transform="translate(800 0) scale(-1 1)"
        />
      </svg>
      <!-- <div class="hiw-line-sig hidden md:block" id="hiw-line-sig">0xA9f2d...</div> -->

      {
        steps.map((step, i) => (
          <div
            class={`hiw-step relative group z-10 ${i < steps.length - 1 ? "md:border-r md:border-white/5" : ""}`}
            data-step={step.id}
          >
            <div class="md:px-8 lg:px-12">
              <!-- Illustration container -->
              <div class="illustration-container relative h-48 md:h-52 mb-10 flex items-center justify-center">
                {/* ── SIGN ── */}
                {step.id === "sign" && (
                  <div class="sign-illustration relative w-full h-full scale-[1.5] md:top-[16px] md:scale-[1.25]">
                    <svg
                      class="w-full h-full overflow-visible"
                      style="overflow: visible;"
                      viewBox="0 0 240 220"
                      fill="none"
                      xmlns="http://www.w3.org/2000/svg"
                    >
                      {/* Document outline */}
                      <g class="sign-doc">
                        <rect x="68" y="24" width="104" height="136" rx="3" fill="#0a0a0a" stroke="none" />
                        <rect
                          class="hiw-doc-outline"
                          x="68"
                          y="24"
                          width="104"
                          height="136"
                          rx="3"
                          fill="none"
                          stroke="white"
                          stroke-width="0.8"
                          opacity="0.35"
                          pathLength="1"
                        />
                        <!-- removed fold corner accent -->
                      </g>

                      {/* Signing elements — fade in, then hold */}
                      <text
                        class="hiw-sign-el"
                        data-idx="0"
                        x="78"
                        y="55"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="7"
                        fill="white"
                        opacity="0"
                      >
                        POST /api/resource
                      </text>
                      <text
                        class="hiw-sign-el"
                        data-idx="1"
                        x="78"
                        y="70"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="6.5"
                        fill="white"
                        opacity="0"
                      >
                        content-digest:
                      </text>
                      <text
                        class="hiw-sign-el"
                        data-idx="2"
                        x="82"
                        y="80"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="6"
                        fill="white"
                        opacity="0"
                      >
                        sha-256=X48E9...
                      </text>
                      <text
                        class="hiw-sign-el"
                        data-idx="3"
                        x="78"
                        y="96"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="6.5"
                        fill="white"
                        opacity="0"
                      >
                        @authority:
                      </text>
                      <text
                        class="hiw-sign-el"
                        data-idx="4"
                        x="82"
                        y="106"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="6"
                        fill="white"
                        opacity="0"
                      >
                        api.example.com
                      </text>
                      {/* Divider */}
                      <line x1="88" y1="118" x2="152" y2="118" stroke="white" stroke-width="0.3" opacity="0.06" />

                      {/* Signature stroke */}
                      <path
                        id="hiw-sig"
                        d="M88 138 C100 124, 108 148, 120 134 C128 126, 136 142, 148 132"
                        stroke="white"
                        stroke-width="1.2"
                        stroke-linecap="round"
                        fill="none"
                        opacity="0"
                        stroke-dasharray="120"
                        stroke-dashoffset="120"
                      />
                    </svg>
                  </div>
                )}

                {/* ── SEND (Server) ── */}
                {step.id === "send" && (
                  <div class="send-illustration relative w-full h-full scale-[1.25] md:scale-[1.1]">
                    <svg class="w-full h-full" viewBox="0 0 240 200" fill="none" xmlns="http://www.w3.org/2000/svg">
                      {/* Server */}
                      <rect x="64" y="40" width="112" height="112" rx="10" fill="#0a0a0a" stroke="none" />
                      <rect x="64" y="40" width="112" height="112" rx="10" fill="none" stroke="white" stroke-width="0.9" opacity="0.35" />
                      <rect x="78" y="56" width="84" height="12" rx="6" fill="white" opacity="0.08" />
                      <rect x="78" y="124" width="84" height="10" rx="5" fill="white" opacity="0.14" />

                      {/* Processing indicator — dashed ring + dot */}
                      <g class="hiw-proc">
                        <circle
                          id="hiw-proc-ring"
                          cx="120"
                          cy="96"
                          r="18"
                          stroke="white"
                          stroke-width="0.7"
                          fill="none"
                          opacity="0.12"
                          stroke-dasharray="6 6"
                        />
                        <circle id="hiw-proc-dot" cx="120" cy="96" r="3" fill="white" opacity="0.22" />
                      </g>
                    </svg>
                  </div>
                )}

                {/* ── VERIFY ── */}
                {step.id === "verify" && (
                  <div class="verify-illustration relative w-full h-full scale-[1.15] md:scale-[1]">
                    <svg class="w-full h-full" viewBox="0 0 240 200" fill="none" xmlns="http://www.w3.org/2000/svg">
                      {/* Verification pulse ring — expands outward */}
                      <circle id="hiw-v-ring" cx="120" cy="84" r="56" stroke="white" stroke-width="0.4" fill="none" opacity="0" />

                      {/* Shield */}
                      <path d="M120 22L76 42V84C76 114 94 138 120 150C146 138 164 114 164 84V42L120 22Z" fill="#0a0a0a" stroke="none" />
                      <path
                        id="hiw-shield-outline"
                        d="M120 22L76 42V84C76 114 94 138 120 150C146 138 164 114 164 84V42L120 22Z"
                        stroke="white"
                        stroke-width="0.8"
                        fill="none"
                        opacity="0.3"
                      />

                      {/* Checkmark */}
                      <path
                        id="hiw-v-check"
                        d="M104 84L114 96L140 66"
                        stroke="var(--hiw-green)"
                        stroke-width="2"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        fill="none"
                        opacity="0"
                        stroke-dasharray="60"
                        stroke-dashoffset="60"
                      />

                      {/* Address pill */}
                      <rect id="hiw-addr-pill" x="52" y="166" width="136" height="24" rx="12" stroke="white" stroke-width="0.5" fill="none" opacity="0.10" />
                      <text
                        id="hiw-addr-text"
                        x="120"
                        y="182"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="10"
                        fill="white"
                        text-anchor="middle"
                        letter-spacing="0.5"
                        opacity="0.18"
                      >
                        0x0000…0000
                      </text>
                      <text
                        id="hiw-ens-text"
                        x="120"
                        y="204"
                        font-family="'SF Mono','Fira Code','Cascadia Code',monospace"
                        font-size="9"
                        fill="white"
                        text-anchor="middle"
                        letter-spacing="0.4"
                        opacity="0.12"
                      >
                        slice.eth
                      </text>
                    </svg>
                  </div>
                )}
              </div>

              <div class="text-center">
                <h3 class="text-lg font-bold uppercase mb-3 tracking-wide">{step.title}</h3>
                <p class="text-[15px] opacity-50 leading-[1.75] max-w-xs mx-auto">{step.description}</p>
              </div>
            </div>
          </div>
        ))
      }
    </div>
  </div>
</section>

<style>
  .bg-grid {
    background-image:
      linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
    background-size: 40px 40px;
  }

  /* ═══════════════════════════════════════════════════════════
     HOVER
     ═══════════════════════════════════════════════════════════ */

  .illustration-container {
    transition: transform 0.24s cubic-bezier(0.16, 1, 0.3, 1);
  }

  .verify-illustration,
  .verify-illustration svg {
    overflow: visible;
  }

  /* ═══════════════════════════════════════════════════════════
     CONNECTION LINE FILL (desktop)
     ═══════════════════════════════════════════════════════════ */

  .hiw-line-sig {
    position: absolute;
    left: 33.7%;
    top: 84px;
    transform: translate(-50%, -50%);
    font-family: "SF Mono", "Fira Code", "Cascadia Code", monospace;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.5);
    letter-spacing: 0.2px;
    line-height: 1;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    z-index: 0;
  }

  #hiw-line-fill {
    stroke-dasharray: 1;
    stroke-dashoffset: 1;
    opacity: 0;
  }

  #hiw-line-return {
    stroke-dasharray: 1;
    stroke-dashoffset: 1;
    opacity: 0;
  }

  .hiw-grid-active #hiw-line-fill {
    animation: none;
  }
  /* ═══════════════════════════════════════════════════════════
     SIGN (fade-in + hold)
     ═══════════════════════════════════════════════════════════ */

  .hiw-sign-el,
  #hiw-sig,
  .hiw-doc-outline {
    opacity: 0;
  }

  .hiw-step.hiw-active .hiw-sign-el {
    animation: hiwSignFadeInHold var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active #hiw-sig {
    animation: hiwSigDrawHold var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active .hiw-doc-outline {
    animation: hiwDocOutline var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active .hiw-sign-el[data-idx="0"] {
    animation-delay: var(--hiw-sign-delay-0);
  }
  .hiw-step.hiw-active .hiw-sign-el[data-idx="1"] {
    animation-delay: var(--hiw-sign-delay-1);
  }
  .hiw-step.hiw-active .hiw-sign-el[data-idx="2"] {
    animation-delay: var(--hiw-sign-delay-2);
  }
  .hiw-step.hiw-active .hiw-sign-el[data-idx="3"] {
    animation-delay: var(--hiw-sign-delay-3);
  }
  .hiw-step.hiw-active .hiw-sign-el[data-idx="4"] {
    animation-delay: var(--hiw-sign-delay-4);
  }
  /* Keyframes are injected by the script from the timing config. */

  /* ═══════════════════════════════════════════════════════════
     SEND (processing)
     ═══════════════════════════════════════════════════════════ */

  #hiw-proc-ring {
    transform-origin: 120px 96px;
    will-change: transform, opacity;
  }

  .hiw-step.hiw-active #hiw-proc-ring {
    animation: hiwProcSpin var(--hiw-cycle) linear infinite;
  }

  @media (max-width: 767px) {
    #hiw-proc-dot {
      opacity: 0.22;
    }
  }
  /* ═══════════════════════════════════════════════════════════
     VERIFY (pulse + check)
     ═══════════════════════════════════════════════════════════ */

  #hiw-v-check {
    transform-origin: 120px 82px;
    will-change: transform, opacity;
  }

  #hiw-v-ring {
    transform-origin: 120px 84px;
    will-change: transform, opacity;
  }

  #hiw-shield-outline {
    transition: stroke 100ms ease-out;
  }

  .hiw-step.hiw-active #hiw-v-check {
    animation: hiwCheckDraw var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active #hiw-v-ring {
    animation: hiwVerifyRing var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active #hiw-shield-outline {
    animation: hiwShieldGlow var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active #hiw-addr-text {
    animation: hiwVerifyAddr var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active #hiw-addr-pill {
    animation: hiwVerifyPill var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-step.hiw-active #hiw-ens-text {
    animation: hiwVerifyEns var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }

  .hiw-grid-active #hiw-line-sig {
    animation: hiwLineSig var(--hiw-cycle) linear infinite;
    animation-fill-mode: both;
  }
  /* Keyframes are injected by the script from the timing config. */

  /* ═══════════════════════════════════════════════════════════
     RESPONSIVE
     ═══════════════════════════════════════════════════════════ */

  @media (max-width: 767px) {
    .illustration-container {
      height: 11rem;
    }

    #hiw-line-sig {
      display: none;
    }

    .hiw-step.hiw-active #hiw-line-fill {
      animation: none;
    }

    .hiw-step[data-step="send"] #hiw-proc-ring {
      animation: hiwProcSpinMobile var(--hiw-proc-spin-period) linear infinite;
      opacity: 1;
    }

    .hiw-step[data-step="send"] #hiw-proc-dot {
      opacity: 0.22;
    }

    .hiw-step.hiw-active[data-step="verify"] #hiw-addr-text {
      animation: hiwVerifyAddrMobile var(--hiw-cycle) linear infinite;
      animation-fill-mode: both;
    }

    .hiw-step.hiw-active[data-step="verify"] #hiw-addr-pill {
      animation: hiwVerifyPillMobile var(--hiw-cycle) linear infinite;
      animation-fill-mode: both;
    }

    .hiw-step.hiw-active[data-step="verify"] #hiw-ens-text {
      animation: hiwEnsMobile var(--hiw-cycle) linear infinite;
      animation-fill-mode: both;
    }

    .hiw-step.hiw-active[data-step="verify"] #hiw-v-check {
      animation: hiwCheckMobile var(--hiw-cycle) linear infinite;
      animation-fill-mode: both;
    }

    .hiw-step.hiw-active[data-step="verify"] #hiw-shield-outline {
      animation: hiwShieldMobile var(--hiw-cycle) linear infinite;
      animation-fill-mode: both;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .illustration-container,
    .illustration-container svg {
      transition: none;
    }

    #hiw-line-fill,
    #hiw-line-sig,
    .hiw-step .hiw-sign-el,
    .hiw-step #hiw-sig,
    .hiw-step #hiw-proc-ring,
    .hiw-step #hiw-addr-text,
    .hiw-step #hiw-addr-pill,
    .hiw-step #hiw-ens-text,
    .hiw-step #hiw-v-check,
    .hiw-step #hiw-v-ring {
      animation: none;
    }

    #hiw-line-fill {
      opacity: 1;
      stroke-dashoffset: 0;
    }

    .hiw-step .hiw-sign-el {
      opacity: 0.55;
    }

    .hiw-step #hiw-sig {
      opacity: 0.65;
      stroke-dashoffset: 0;
    }

    .hiw-step #hiw-v-check {
      opacity: 0.88;
      stroke-dashoffset: 0;
      transform: scale(1);
    }

    .hiw-step #hiw-v-ring {
      opacity: 0.12;
      transform: scale(1.02);
    }
  }
</style>

<script>
  (function () {
    const FINAL_ADDR = '0x71C7...d93A';
    const PLACEHOLDER = '0x0000...0000';
    const HEX = '0123456789abcdefABCDEF';

    // ⬇️ All timing knobs live here.
    const TIMING = {
      // SIGN (document / text / signature)
      signTextMs: 600, // time for sign text block to fade in
      signSigMs: 500, // signature draw duration
      signDelaysMs: [0, 80, 160, 240, 320], // per-line sign text delays

      // LINE - three phases with explicit delays
      lineStartDelayMs: 200, // delay after sign before purple line starts
      lineSignToSendMs: 400, // purple line travel: sign → send
      lineDelayAtSendMs: 250, // purple line waits at send (process plays during this)
      lineSendToVerifyMs: 400, // purple line travel: send → verify
      lineDelayAtVerifyMs: 1400, // purple line waits at verify (verify anim plays during this)
      lineReturnMs: 600, // green line travel: verify → send

      // LINE SIGNATURE LABEL
      lineSigFadeMs: 150, // fade-in time for the 0xA9f2d... label (appears when line starts)

      // POST-RETURN
      holdMs: 2000, // hold after return completes before fade-out
      fadeOutMs: 500, // everything fades out together
      cycleGapMs: 200, // pause between loops (max 1s)

      // PROCESS (plays during lineDelayAtSendMs)
      spinnerFadeMs: 150, // fade in/out duration
      processSpinMs: 2000, // spin duration
      spinnerRps: 1, // rotations per second (fixed speed)

      // VERIFY (plays during lineDelayAtVerifyMs)
      scrambleMs: 1200, // scramble duration for address
      verifyDrawMs: 300, // checkmark draw duration
      verifySettleMs: 200, // checkmark settle time
      verifyPulseMs: 1000, // ring expand duration
      verifyPulseFadeMs: 500, // ring fade-out duration
      addrFadeInMs: 200, // address fade-in after line arrives at verify
      ensFadeInMs: 150, // ENS fade-in time after scramble ends

      // SCRAMBLE animation mechanics
      scrambleTickMs: 70, // update interval for scramble text
      staggerMs: 60, // per-character stagger
      minCharResolveMs: 120, // minimum time per character to resolve

      // MOBILE (per-step cycles)
      mobile: {
        signCycleMs: 3000, // sign loop duration
        sendCycleMs: 1500, // send loop duration
        verifyCycleMs: 0, // 0 = auto
        verifyStartDelayMs: 1000, // delay before verify fade-in/scramble
        scrambleMs: 1000, // mobile scramble duration
        verifyHoldMs: 2000, // hold after resolve before fade-out
        fadeOutMs: 500 // mobile fade-out duration
      }
    };

    function buildTimeline(timing: typeof TIMING) {
      // SIGN phase
      const signTextEnd = timing.signTextMs;
      const signEnd = signTextEnd  + timing.signSigMs;

      // LINE phase 1: sign → send (purple)
      const lineStart = signEnd + timing.lineStartDelayMs;
      const lineSigStart = lineStart;
      const lineSigEnd = lineSigStart + timing.lineSigFadeMs;
      const lineSendArrive = lineStart + timing.lineSignToSendMs;

      // LINE phase 2: wait at send (process plays during this)
      const lineSendPauseEnd = lineSendArrive + timing.lineDelayAtSendMs;

      // LINE phase 3: send → verify (purple)
      const lineVerifyArrive = lineSendPauseEnd + timing.lineSendToVerifyMs;

      // LINE phase 4: wait at verify (verify animation plays during this)
      const lineVerifyPauseEnd = lineVerifyArrive + timing.lineDelayAtVerifyMs;

      // LINE phase 5: verify → send (green return)
      const returnStart = lineVerifyPauseEnd;
      const returnEnd = returnStart + timing.lineReturnMs;

      // POST-RETURN: hold then fade out together
      const holdEnd = returnEnd + timing.holdMs;
      const fadeOutStart = holdEnd;
      const fadeOutEnd = fadeOutStart + timing.fadeOutMs;
      const cycleMs = fadeOutEnd + timing.cycleGapMs;

      // PROCESS animation (plays during lineDelayAtSendMs)
      const processStart = lineSendArrive;
      const processFadeInEnd = processStart + timing.spinnerFadeMs;
      const processSpinEnd = processFadeInEnd + timing.processSpinMs;
      const processFadeOutEnd = processSpinEnd + timing.spinnerFadeMs;

      // VERIFY animation sequence:
      // 1. Scramble starts when line arrives at verify
      // 2. When scramble ends, address is resolved and ENS fades in
      // 3. When ENS appears, checkmark starts drawing
      // 4. When checkmark finishes, return line starts
      const verifyStart = lineVerifyArrive;
      const scrambleEnd = verifyStart + timing.scrambleMs;
      const ensFadeInStart = scrambleEnd;
      const ensFadeInEnd = ensFadeInStart + timing.ensFadeInMs;
      const checkStart = ensFadeInStart; // checkmark starts when ENS starts appearing
      const checkDrawEnd = checkStart + timing.verifyDrawMs;
      const checkSettleEnd = checkDrawEnd + timing.verifySettleMs;

      console.log('Timeline (ms):', {
        signEnd,
        lineStart,
        lineSendArrive,
        lineSendPauseEnd,
        lineVerifyArrive,
        verifyStart,
        scrambleEnd,
        ensFadeInEnd,
        checkDrawEnd,
        lineVerifyPauseEnd,
        returnStart,
        returnEnd,
        holdEnd,
        cycleMs,
      });

      return {
        signTextEnd,
        signEnd,
        lineStart,
        lineSigStart,
        lineSigEnd,
        lineSendArrive,
        lineSendPauseEnd,
        lineVerifyArrive,
        lineVerifyPauseEnd,
        returnStart,
        returnEnd,
        holdEnd,
        fadeOutStart,
        fadeOutEnd,
        cycleMs,
        // Process
        processStart,
        processFadeInEnd,
        processSpinEnd,
        processFadeOutEnd,
        // Verify
        verifyStart,
        scrambleEnd,
        ensFadeInStart,
        ensFadeInEnd,
        checkStart,
        checkDrawEnd,
        checkSettleEnd,
      };
    }

    function injectTimingStyles(timing: typeof TIMING, timeline: ReturnType<typeof buildTimeline>) {
      const safeMs = (ms: number) => (Number.isFinite(ms) ? ms : 0);
      const pct = (ms: number) => {
        if (!Number.isFinite(timeline.cycleMs) || timeline.cycleMs <= 0) return 0;
        return Math.min(100, Math.max(0, (safeMs(ms) / timeline.cycleMs) * 100));
      };
      const p = (ms: number) => `${pct(ms).toFixed(2)}%`;
      const pm = (ms: number) => {
        if (!Number.isFinite(mobileVerifyCycleMs) || mobileVerifyCycleMs <= 0) return "0%";
        const value = Math.min(100, Math.max(0, (safeMs(ms) / mobileVerifyCycleMs) * 100));
        return `${value.toFixed(2)}%`;
      };
      const jumpPct = (ms: number, maxMs: number) => `${Math.min(pct(ms) + 0.01, pct(maxMs)).toFixed(2)}%`;
      const mobileVerifyStartDelay = timing.mobile.verifyStartDelayMs ?? 1000;
      const mobileScrambleMs = timing.mobile.scrambleMs ?? timing.scrambleMs;
      const mobileHoldMs = timing.mobile.verifyHoldMs ?? 2000;
      const mobileFadeOutMs = timing.mobile.fadeOutMs ?? timing.fadeOutMs;
      const mobileVerifyCycleMs =
        timing.mobile.verifyCycleMs ||
        (mobileVerifyStartDelay + mobileScrambleMs + mobileHoldMs + mobileFadeOutMs + timing.cycleGapMs);

      // Sign animation timing
      const sigStart = timeline.signTextEnd;
      const sigEnd = timeline.signEnd;

      // Verify animation timing (from timeline)
      const checkStart = timeline.checkStart;
      const checkDrawEnd = timeline.checkDrawEnd;
      const checkSettleEnd = timeline.checkSettleEnd;
      const ringPeak = checkStart + timing.verifyPulseMs;
      const ringEnd = ringPeak + timing.verifyPulseFadeMs;
      const addrFadeInEnd = timeline.verifyStart + timing.addrFadeInMs;
      const mobileScrambleStart = mobileVerifyStartDelay;
      const mobileScrambleEnd = mobileScrambleStart + mobileScrambleMs;
      const mobileEnsFadeInEnd = mobileScrambleEnd + timing.ensFadeInMs;
      const mobileAddrFadeInEnd = mobileScrambleStart + timing.addrFadeInMs;
      const mobileCheckStart = mobileScrambleEnd;
      const mobileCheckDrawEnd = mobileCheckStart + timing.verifyDrawMs;
      const mobileCheckSettleEnd = mobileCheckDrawEnd + timing.verifySettleMs;
      const mobileFadeOutStart = mobileScrambleEnd + mobileHoldMs;
      const mobileFadeOutEnd = mobileFadeOutStart + mobileFadeOutMs;

      const styleText = `
#hiw-grid {
  --hiw-cycle: ${timeline.cycleMs}ms;
  --hiw-green: rgba(34, 197, 94, 0.95);
  --hiw-proc-spin-deg: ${(timing.processSpinMs / 1000) * timing.spinnerRps * 360}deg;
  --hiw-proc-spin-period: ${1000 / timing.spinnerRps}ms;
  --hiw-sign-delay-0: ${timing.signDelaysMs[0]}ms;
  --hiw-sign-delay-1: ${timing.signDelaysMs[1]}ms;
  --hiw-sign-delay-2: ${timing.signDelaysMs[2]}ms;
  --hiw-sign-delay-3: ${timing.signDelaysMs[3]}ms;
  --hiw-sign-delay-4: ${timing.signDelaysMs[4]}ms;
}

@media (max-width: 767px) {
  .hiw-step[data-step="sign"] { --hiw-cycle: ${timing.mobile.signCycleMs}ms; }
  .hiw-step[data-step="send"] { --hiw-cycle: ${timing.mobile.sendCycleMs}ms; }
  .hiw-step[data-step="verify"] { --hiw-cycle: ${mobileVerifyCycleMs}ms; }
}

@keyframes hiwSignFadeInHold {
  0% { opacity: 0; }
  ${p(timeline.signTextEnd)} { opacity: 0.55; }
  ${p(timeline.fadeOutStart)} { opacity: 0.55; }
  ${p(timeline.fadeOutEnd)} { opacity: 0; }
  100% { opacity: 0; }
}

@keyframes hiwDocOutline {
  0% { opacity: 0; stroke-dasharray: 1; stroke-dashoffset: 1; }
  ${p(timeline.signTextEnd)} { opacity: 0.35; stroke-dashoffset: 0; }
  ${p(timeline.fadeOutStart)} { opacity: 0.35; stroke-dashoffset: 0; }
  ${p(timeline.fadeOutEnd)} { opacity: 0; stroke-dashoffset: 0; }
  100% { opacity: 0; stroke-dashoffset: 0; }
}

@keyframes hiwSigDrawHold {
  0% { opacity: 0; stroke-dashoffset: 120; }
  ${p(sigStart)} { opacity: 0; stroke-dashoffset: 120; }
  ${jumpPct(sigStart, sigEnd)} { opacity: 1; stroke-dashoffset: 120; }
  ${p(sigEnd)} { opacity: 1; stroke-dashoffset: 0; }
  ${p(timeline.fadeOutStart)} { opacity: 1; stroke-dashoffset: 0; }
  ${p(timeline.fadeOutEnd)} { opacity: 0; stroke-dashoffset: 0; }
  100% { opacity: 0; stroke-dashoffset: 0; }
}

@keyframes hiwProcSpin {
  0% { opacity: 0; transform: rotate(0deg); }
  ${p(timeline.processStart)} { opacity: 0; transform: rotate(0deg); }
  ${p(timeline.processFadeInEnd)} { opacity: 1; transform: rotate(0deg); }
  ${p(timeline.processSpinEnd)} { opacity: 1; transform: rotate(var(--hiw-proc-spin-deg)); }
  ${p(timeline.processFadeOutEnd)} { opacity: 0; transform: rotate(var(--hiw-proc-spin-deg)); }
  100% { opacity: 0; transform: rotate(var(--hiw-proc-spin-deg)); }
}

@keyframes hiwCheckDraw {
  0% { opacity: 0; stroke-dashoffset: 60; transform: scale(1); }
  ${p(checkStart)} { opacity: 0; stroke-dashoffset: 60; transform: scale(1); }
  ${p(checkDrawEnd)} { opacity: 1; stroke-dashoffset: 0; transform: scale(1.06); }
  ${p(checkSettleEnd)} { opacity: 0.88; stroke-dashoffset: 0; transform: scale(1); }
  ${p(timeline.fadeOutStart)} { opacity: 0.88; stroke-dashoffset: 0; transform: scale(1); }
  ${p(timeline.fadeOutEnd)} { opacity: 0; stroke-dashoffset: 0; transform: scale(1); }
  100% { opacity: 0; stroke-dashoffset: 0; transform: scale(1); }
}

@keyframes hiwShieldGlow {
  0% { stroke: white; opacity: 0.3; }
  ${p(checkStart)} { stroke: white; opacity: 0.3; }
  ${p(checkDrawEnd)} { stroke: var(--hiw-green); opacity: 1; }
  ${p(timeline.fadeOutStart)} { stroke: var(--hiw-green); opacity: 1; }
  ${p(timeline.fadeOutEnd)} { stroke: white; opacity: 0.3; }
  100% { stroke: white; opacity: 0.3; }
}

@keyframes hiwVerifyRing {
  0% { opacity: 0; transform: scale(0.85); }
  ${p(checkStart)} { opacity: 0; transform: scale(0.85); }
  ${p(ringPeak)} { opacity: 0.12; transform: scale(1.02); }
  ${p(ringEnd)} { opacity: 0; transform: scale(1.12); }
  100% { opacity: 0; transform: scale(1.12); }
}

@keyframes hiwVerifyAddr {
  0% { opacity: 0.18; }
  ${p(timeline.verifyStart)} { opacity: 0.18; }
  ${p(addrFadeInEnd)} { opacity: 0.62; }
  ${p(timeline.scrambleEnd)} { opacity: 0.62; }
  ${p(timeline.lineVerifyPauseEnd)} { opacity: 0.65; }
  ${p(timeline.fadeOutStart)} { opacity: 0.65; }
  ${p(timeline.fadeOutEnd)} { opacity: 0.18; }
  100% { opacity: 0.18; }
}

@keyframes hiwVerifyPill {
  0% { opacity: 0.1; }
  ${p(timeline.verifyStart)} { opacity: 0.1; }
  ${p(addrFadeInEnd)} { opacity: 0.38; }
  ${p(timeline.scrambleEnd)} { opacity: 0.38; }
  ${p(timeline.lineVerifyPauseEnd)} { opacity: 0.4; }
  ${p(timeline.fadeOutStart)} { opacity: 0.4; }
  ${p(timeline.fadeOutEnd)} { opacity: 0.1; }
  100% { opacity: 0.1; }
}

@keyframes hiwVerifyEns {
  0% { opacity: 0; }
  ${p(timeline.ensFadeInStart)} { opacity: 0; }
  ${p(timeline.ensFadeInEnd)} { opacity: 0.6; }
  ${p(timeline.fadeOutStart)} { opacity: 0.6; }
  ${p(timeline.fadeOutEnd)} { opacity: 0; }
  100% { opacity: 0; }
}

@keyframes hiwVerifyAddrMobile {
  0% { opacity: 0.18; }
  ${pm(mobileVerifyStartDelay)} { opacity: 0.18; }
  ${pm(mobileAddrFadeInEnd)} { opacity: 1; }
  ${pm(mobileFadeOutStart)} { opacity: 1; }
  ${pm(mobileFadeOutEnd)} { opacity: 0.18; }
  100% { opacity: 0.18; }
}

@keyframes hiwVerifyPillMobile {
  0% { opacity: 0.1; }
  ${pm(mobileVerifyStartDelay)} { opacity: 0.1; }
  ${pm(mobileAddrFadeInEnd)} { opacity: 0.4; }
  ${pm(mobileFadeOutStart)} { opacity: 0.4; }
  ${pm(mobileFadeOutEnd)} { opacity: 0.1; }
  100% { opacity: 0.1; }
}

@keyframes hiwCheckMobile {
  0% { opacity: 0; stroke-dashoffset: 60; transform: scale(1); }
  ${pm(mobileCheckStart)} { opacity: 0; stroke-dashoffset: 60; transform: scale(1); }
  ${pm(mobileCheckDrawEnd)} { opacity: 1; stroke-dashoffset: 0; transform: scale(1.06); }
  ${pm(mobileCheckSettleEnd)} { opacity: 0.88; stroke-dashoffset: 0; transform: scale(1); }
  ${pm(mobileFadeOutStart)} { opacity: 0.88; stroke-dashoffset: 0; transform: scale(1); }
  ${pm(mobileFadeOutEnd)} { opacity: 0; stroke-dashoffset: 0; transform: scale(1); }
  100% { opacity: 0; stroke-dashoffset: 0; transform: scale(1); }
}

@keyframes hiwLineSig {
  0% { opacity: 0; }
  ${p(timeline.lineSigStart)} { opacity: 0; }
  ${p(timeline.lineSigEnd)} { opacity: 0.9; }
  ${p(timeline.fadeOutStart)} { opacity: 0.9; }
  ${p(timeline.fadeOutEnd)} { opacity: 0; }
  100% { opacity: 0; }
}

@keyframes hiwProcSpinMobile {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes hiwEnsMobile {
  0% { opacity: 0; }
  ${pm(mobileScrambleEnd)} { opacity: 0; }
  ${pm(mobileEnsFadeInEnd)} { opacity: 0.6; }
  ${pm(mobileFadeOutStart)} { opacity: 0.6; }
  ${pm(mobileFadeOutEnd)} { opacity: 0; }
  100% { opacity: 0; }
}

@keyframes hiwShieldMobile {
  0% { stroke: white; opacity: 0.3; }
  ${pm(mobileScrambleEnd)} { stroke: white; opacity: 0.3; }
  ${pm(mobileEnsFadeInEnd)} { stroke: var(--hiw-green); opacity: 1; }
  ${pm(mobileFadeOutStart)} { stroke: var(--hiw-green); opacity: 1; }
  ${pm(mobileFadeOutEnd)} { stroke: white; opacity: 0.3; }
  100% { stroke: white; opacity: 0.3; }
}
      `.trim();

      let styleEl = document.getElementById('hiw-timing-styles') as HTMLStyleElement | null;
      if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'hiw-timing-styles';
        document.head.appendChild(styleEl);
      }
      styleEl.textContent = styleText;
    }

    function clamp(v: number, lo = 0, hi = 1) {
      return Math.max(lo, Math.min(hi, v));
    }

    function isStaticChar(ch: string, index: number) {
      return ch === '.' || ch === '…' || (ch === 'x' && index === 1) || (ch === '0' && index === 0);
    }

    function supportsReducedMotion() {
      return window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    }

    function createVerifyAnimator(verifyStep: HTMLElement) {
      const addrText = verifyStep.querySelector<SVGTextElement>('#hiw-addr-text');
      const addrPill = verifyStep.querySelector<SVGRectElement>('#hiw-addr-pill');
      if (!addrText || !addrPill) return null;

      let scrambleInterval: number | null = null;
      let timers: number[] = [];
      let animationBound = false;
      let currentStartDelay = 0;
      let currentFadeOutDelay = 0;
      let onAnimTick: (() => void) | null = null;
      let fallbackTimer: number | null = null;

      const setPlaceholder = () => {
        addrText.textContent = PLACEHOLDER;
      };

      const setFinal = () => {
        addrText.textContent = FINAL_ADDR;
      };

      const clearTimers = () => {
        timers.forEach((t) => clearTimeout(t));
        timers = [];
        if (fallbackTimer !== null) {
          clearTimeout(fallbackTimer);
          fallbackTimer = null;
        }
        if (scrambleInterval !== null) {
          clearInterval(scrambleInterval);
          scrambleInterval = null;
        }
      };

      const runCycle = (startDelay: number, cycleMs: number, fadeOutDelay: number, scrambleMs: number) => {
        clearTimers();
        if (!verifyStep.classList.contains('hiw-active')) return;

        currentStartDelay = Math.max(0, startDelay);
        currentFadeOutDelay = Math.max(currentStartDelay, fadeOutDelay);
        const activeScrambleMs = Math.max(0, scrambleMs);

        const startOnce = () => {
          clearTimers();
          if (!verifyStep.classList.contains('hiw-active')) return;
          setPlaceholder();
          const startTimer = window.setTimeout(() => {
            const start = performance.now();
            scrambleInterval = window.setInterval(() => {
              const t = performance.now() - start;
              const tick = Math.floor(t / TIMING.scrambleTickMs);
              const chars = FINAL_ADDR.split('');
              const perCharDelay = Math.min(TIMING.staggerMs, activeScrambleMs / Math.max(1, chars.length - 1));
              const perCharDuration = Math.max(
                TIMING.minCharResolveMs,
                activeScrambleMs - perCharDelay * (chars.length - 1)
              );
              const totalDuration = activeScrambleMs;
              const output = chars
                .map((ch, i) => {
                  if (isStaticChar(ch, i)) return ch;
                  const local = clamp((t - i * perCharDelay) / perCharDuration);
                  if (local >= 1) return ch;
                  return HEX[(i * 13 + tick * 7) % HEX.length];
                })
                .join('');
              addrText.textContent = output;
              if (t >= totalDuration) {
                if (scrambleInterval !== null) {
                  clearInterval(scrambleInterval);
                  scrambleInterval = null;
                }
                setFinal();
              }
            }, TIMING.scrambleTickMs);
          }, currentStartDelay);

          const fadeOutTimer = window.setTimeout(() => {
            setPlaceholder();
          }, currentFadeOutDelay);

          timers.push(startTimer, fadeOutTimer);
        };

        if (!animationBound) {
          onAnimTick = () => {
            if (fallbackTimer !== null) {
              clearTimeout(fallbackTimer);
              fallbackTimer = null;
            }
            startOnce();
          };
          addrText.addEventListener("animationstart", onAnimTick);
          addrText.addEventListener("animationiteration", onAnimTick);
          animationBound = true;
        }

        // Fallback if animation events don't fire promptly.
        fallbackTimer = window.setTimeout(startOnce, 50);
      };

      const stop = () => {
        clearTimers();
        if (animationBound && onAnimTick) {
          addrText.removeEventListener("animationstart", onAnimTick);
          addrText.removeEventListener("animationiteration", onAnimTick);
          animationBound = false;
          onAnimTick = null;
        }
      };

      return { runCycle, stop, setFinal };
    }

    function init() {
      const grid = document.getElementById('hiw-grid');
      if (!grid) return;

      const steps = Array.from(grid.querySelectorAll('.hiw-step'));
      const lineFill = grid.querySelector<SVGLineElement>('#hiw-line-fill');
      const lineReturn = grid.querySelector<SVGLineElement>('#hiw-line-return');
      const isMobile = window.matchMedia && window.matchMedia('(max-width: 767px)').matches;
      let timeline = buildTimeline(TIMING);
      injectTimingStyles(TIMING, timeline);
      const mobileVerifyStartDelayMs = TIMING.mobile.verifyStartDelayMs ?? 1000;
      const mobileScrambleMs = TIMING.mobile.scrambleMs ?? TIMING.scrambleMs;
      const mobileHoldMs = TIMING.mobile.verifyHoldMs ?? 2000;
      const mobileFadeOutMs = TIMING.mobile.fadeOutMs ?? TIMING.fadeOutMs;
      const mobileVerifyCycleMs =
        TIMING.mobile.verifyCycleMs ||
        (mobileVerifyStartDelayMs + mobileScrambleMs + mobileHoldMs + mobileFadeOutMs + TIMING.cycleGapMs);

      const cycleMs = isMobile ? mobileVerifyCycleMs : timeline.cycleMs;
      const verifyDelayMs = isMobile ? mobileVerifyStartDelayMs : timeline.verifyStart;
      const verifyFadeOutDelayMs = isMobile
        ? mobileVerifyStartDelayMs + mobileScrambleMs + mobileHoldMs + mobileFadeOutMs
        : Math.max(0, timeline.fadeOutEnd);
      const reduceMotion = supportsReducedMotion();

      const verifyStep = steps.find((s) => s.getAttribute('data-step') === 'verify') as HTMLElement | undefined;
      const verifyAnimator = verifyStep ? createVerifyAnimator(verifyStep) : null;

      if (reduceMotion) {
        if (verifyAnimator) verifyAnimator.setFinal();
        return;
      }

      let lineAnimation: Animation | null = null;
      let lineReturnAnimation: Animation | null = null;
      const startLine = () => {
        if (!lineFill) return;
        if (lineAnimation) lineAnimation.cancel();
        if (lineReturnAnimation) lineReturnAnimation.cancel();
        timeline = buildTimeline(TIMING);
        injectTimingStyles(TIMING, timeline);
        if (!Number.isFinite(timeline.cycleMs) || timeline.cycleMs <= 0) return;

        const cycleMs = timeline.cycleMs;
        const toOffset = (ms: number) => Math.max(0, Math.min(1, ms / cycleMs));

        // Calculate offsets from timeline
        const lineStart = toOffset(timeline.lineStart);
        const lineSendArrive = toOffset(timeline.lineSendArrive);
        const lineSendPauseEnd = toOffset(timeline.lineSendPauseEnd);
        const lineVerifyArrive = toOffset(timeline.lineVerifyArrive);
        const lineVerifyPauseEnd = toOffset(timeline.lineVerifyPauseEnd);
        const returnStart = toOffset(timeline.returnStart);
        const returnEnd = toOffset(timeline.returnEnd);
        const holdEnd = toOffset(timeline.holdEnd);
        const fadeOutEnd = toOffset(timeline.fadeOutEnd);

        console.log('Line animation offsets:', {
          cycleMs,
          lineStart: `${(lineStart * 100).toFixed(1)}%`,
          lineSendArrive: `${(lineSendArrive * 100).toFixed(1)}%`,
          lineSendPauseEnd: `${(lineSendPauseEnd * 100).toFixed(1)}%`,
          lineVerifyArrive: `${(lineVerifyArrive * 100).toFixed(1)}%`,
          lineVerifyPauseEnd: `${(lineVerifyPauseEnd * 100).toFixed(1)}%`,
          returnStart: `${(returnStart * 100).toFixed(1)}%`,
          returnEnd: `${(returnEnd * 100).toFixed(1)}%`,
          holdEnd: `${(holdEnd * 100).toFixed(1)}%`,
        });

        // Purple line: sign → send → verify
        lineAnimation = lineFill.animate(
          [
            { strokeDashoffset: 1, opacity: 0, offset: 0 },
            { strokeDashoffset: 1, opacity: 0, offset: lineStart },

            // Phase 1: sign → send (line reaches 50%)
            { strokeDashoffset: 0.5, opacity: 1, offset: lineSendArrive },

            // Phase 2: wait at send (process plays)
            { strokeDashoffset: 0.5, opacity: 1, offset: lineSendPauseEnd },

            // Phase 3: send → verify (line reaches 0%)
            { strokeDashoffset: 0, opacity: 1, offset: lineVerifyArrive },

            // Phase 4: wait at verify (verify anim plays)
            { strokeDashoffset: 0, opacity: 1, offset: lineVerifyPauseEnd },

            // Stay visible during return and hold
            { strokeDashoffset: 0, opacity: 1, offset: holdEnd },

            // Fade out (fixed duration), then idle gap
            { strokeDashoffset: 0, opacity: 0, offset: fadeOutEnd },
            { strokeDashoffset: 0, opacity: 0, offset: 1 }
          ],
          {
            duration: cycleMs,
            iterations: Infinity,
            easing: 'linear'
          }
        );

        // Green return line: verify → send (after verify animation completes)
        if (lineReturn) {
          lineReturnAnimation = lineReturn.animate(
            [
              { strokeDashoffset: 1, opacity: 0, offset: 0 },
              { strokeDashoffset: 1, opacity: 0, offset: returnStart },
              { strokeDashoffset: 0, opacity: 1, offset: returnEnd },
              { strokeDashoffset: 0, opacity: 1, offset: holdEnd },
              { strokeDashoffset: 0, opacity: 0, offset: fadeOutEnd },
              { strokeDashoffset: 0, opacity: 0, offset: 1 }
            ],
            {
              duration: cycleMs,
              iterations: Infinity,
              easing: 'linear'
            }
          );
        }
      };

      const stopLine = () => {
        if (lineAnimation) {
          lineAnimation.cancel();
          lineAnimation = null;
        }
        if (lineReturnAnimation) {
          lineReturnAnimation.cancel();
          lineReturnAnimation = null;
        }
      };

      if (!('IntersectionObserver' in window)) {
        steps.forEach((s) => s.classList.add('hiw-active'));
        grid.classList.add('hiw-grid-active');
        startLine();
        if (verifyAnimator) {
          const scrambleMs = isMobile ? mobileScrambleMs : TIMING.scrambleMs;
          verifyAnimator.runCycle(verifyDelayMs, cycleMs, verifyFadeOutDelayMs, scrambleMs);
        }
        return;
      }

      if (isMobile) {
        // ── Mobile: each step runs from frame 0 when it enters viewport ──
        const stepObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((e) => {
              const el = e.target as HTMLElement;
              if (e.isIntersecting) {
                el.classList.add('hiw-active');
                if (verifyAnimator && el === verifyStep) {
                  const scrambleMs = isMobile ? mobileScrambleMs : TIMING.scrambleMs;
                  verifyAnimator.runCycle(verifyDelayMs, cycleMs, verifyFadeOutDelayMs, scrambleMs);
                }
              } else {
                el.classList.remove('hiw-active');
                if (verifyAnimator && el === verifyStep) verifyAnimator.stop();
              }
            });
          },
          { threshold: 0.4 }
        );

        steps.forEach((s) => stepObserver.observe(s));
        return;
      }

      // ── Desktop: full sequence when grid enters viewport ──
      const gridObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((e) => {
            if (e.isIntersecting) {
              grid.classList.add('hiw-grid-active');
              steps.forEach((s) => s.classList.add('hiw-active'));
              startLine();
              if (verifyAnimator) {
                const scrambleMs = isMobile ? mobileScrambleMs : TIMING.scrambleMs;
                verifyAnimator.runCycle(verifyDelayMs, cycleMs, verifyFadeOutDelayMs, scrambleMs);
              }
            } else {
              grid.classList.remove('hiw-grid-active');
              steps.forEach((s) => s.classList.remove('hiw-active'));
              stopLine();
              if (verifyAnimator) verifyAnimator.stop();
            }
          });
        },
        { threshold: 0.35 }
      );

      gridObserver.observe(grid);
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
</script>
